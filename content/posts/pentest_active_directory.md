+++
title = "Pentest - Active Directory"
author = ["svejk"]
tags = ["p200", "activeDirectory", "pentest"]
draft = false
+++

## Active Directory Enumeration {#active-directory-enumeration}


### Legacy Windows Tools {#legacy-windows-tools}

Use `net.exe` to gather user information

```shell { linenos=true, linenostart=1 }
net user /domain
```

A more detailed view of specific users in the output above:

```shell { linenos=true, linenostart=1 }
net user <username> /domain
```

Enumerate groups:

```shell { linenos=true, linenostart=1 }
net group /domain
```

Specifying a group:

```shell { linenos=true, linenostart=1 }
net group <groupname> /domain
```


### PowerShell and .NET {#powershell-and-dot-net}

When RSAT tools aren't available, we can use an Active Directory Services Interface [ADSI](https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi) (a set of interfaces built on [COM](https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi(soft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsis://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal)) as an LDAP provider.  The LDAP ADsPath we need to consider to interact with the AD service is based on the following recipe:

```shell { linenos=true, linenostart=1 }
LDAP://HostName[:PortNumber][/DistinguishedName]
```

We could use the domain as the hostname, but this could potentially resolve to any of the DCs on the domain. To obtain the most accurate information, we'll look for the primary domain controller (PDC), which is the one holding the _PdcRoleOwner_ attribute.

Looking to .NET, we have the namespace _System.DirectoryServices.ActiveDirectory_, and specifically the _Domain Class_ therein. A method of interest is the following:

```shell { linenos=true, linenostart=1 }
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
```

which will provide the _PdcRoleOwner_ property, among others. We can use ADSI directly in PowerShell to retrieve the DN. We'll use two single quotes to indicate that the search starts at the top of the AD hierarchy.

```shell { linenos=true, linenostart=1 }
([adsi]'').distinguishedName
```

Putting it together, we can obtain the LDAP string:

```shell { linenos=true, linenostart=1 }
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName
$LDAP = "LDAP://$PDC/$DN"
$LDAP
```

In order to gather information, utilize two other classes in the _System.DirectoryServices_ namespace: _DirectoryEntry_ and _DirectorySearcher_. We'll pass the LDAP path to _DirectoryEntry_ in order to start the search at the top of the directory heirarchy. To perform queries with _DirectorySearcher_, we'll pass the _DirectoryEntry_ object as the _SearchRoot_.

```shell { linenos=true, linenostart=1 }
$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.filter="samAccountType=805306368"
$dirsearcher.FindAll()
```

where we've added the _samAccountType_ for users.  Iterate through the user properties and print:

```shell { linenos=true, linenostart=1 }
Foreach($obj in $result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }

    Write-Host "-------------------------------"
}
```

Wrap all of the above into a function:

```shell { linenos=true, linenostart=1 }
function LDAPSearch {
    param (
        [string]$LDAPQuery
    )

    $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
    $DistinguishedName = ([adsi]'').distinguishedName

    $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")

    $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)

    return $DirectorySearcher.FindAll()

}
```

We can import and run `LDAPSearch -LDAPQuery "(samAccountType=805306368)"`, or `LDAPSearch -LDAPQuery "(objectclass=group)"`


### Permissions and Sessions {#permissions-and-sessions}


#### PowerView: `Find-LocalAdminAccess` {#powerview-find-localadminaccess}

Determine if the current user has admin access on any domain machines.  Relies on _OpenServiceW function_, which will connect to the _Service Control Manager (SCM)_ on the target machines.


#### PowerView: `Get-NetSession` {#powerview-get-netsession}

Determine which users are logged into which machines. It utilizes two Windows APIs: _NetWkstaUserEnum_ and _NetSessionEnum_. First requires admin privs, the second does not.


#### SysInternals: `PSLoggedon` {#sysinternals-psloggedon}


### Service Accounts {#service-accounts}


#### PowerView: `Get-NetUser -SPN | select samaccountname,serviceprincipalname` {#powerview-get-netuser-spn-select-samaccountname-serviceprincipalname}

Enumerate Service Principal Names (SPNs)


### Object Permissions {#object-permissions}


#### PowerView: `Get-ObjectAcl` {#powerview-get-objectacl}

-   Check the _ActiveDirectoryRights_ and _SecurityIdentifier_ attributes
-   Dealing with SIDs: `Convert-SidToName`


### [Bloodhound]({{< relref "bloodhound.md" >}}) {#bloodhound--bloodhound-dot-md}


## Active Directory Authentication {#active-directory-authentication}


### [NTLM Authentication]({{< relref "ntlm_authentication.md" >}}) {#ntlm-authentication--ntlm-authentication-dot-md}


### [Kerberos Authentication]({{< relref "kerberos_authentication.md" >}}) {#kerberos-authentication--kerberos-authentication-dot-md}


### Cached AD Credentials {#cached-ad-credentials}


#### [Mimikatz]({{< relref "mimikatz.md" >}}) {#mimikatz--mimikatz-dot-md}


## Attacking Active Directory {#attacking-active-directory}


### [Kerbrute Enumeration]({{< relref "kerbrute_enumeration.md" >}}) {#kerbrute-enumeration--kerbrute-enumeration-dot-md}

Privileges: No domain access required


### [Pass the Ticket (PtT) Attack]({{< relref "pass_the_ticket_ptt_attack.md" >}}) {#pass-the-ticket--ptt--attack--pass-the-ticket-ptt-attack-dot-md}

Privileges: Domain user access


### [Kerberoasting]({{< relref "kerberoasting.md" >}}) {#kerberoasting--kerberoasting-dot-md}

Privileges: Access as any user


### [AS-REP Roasting]({{< relref "as_rep_roasting.md" >}}) {#as-rep-roasting--as-rep-roasting-dot-md}

Privileges: Access as any user


### [Golden Ticket]({{< relref "golden_ticket.md" >}}) {#golden-ticket--golden-ticket-dot-md}

Privileges: Full domain compromise (domain admin)


### [Silver Ticket]({{< relref "silver_ticket.md" >}}) {#silver-ticket--silver-ticket-dot-md}

Privileges: Service hash


### [Pentest - Active Directory - Skeleton Key]({{< relref "pentest_active_directory_skeleton_key.md" >}}) {#pentest-active-directory-skeleton-key--pentest-active-directory-skeleton-key-dot-md}

Privileges: Full domain compromise (domain admin)


## References {#references}

-   [dw3113r](https://dw3113r.com/2022/07/20/active-directory-attack-cheat-sheet/)
