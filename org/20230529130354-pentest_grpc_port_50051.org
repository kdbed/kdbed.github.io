:PROPERTIES:
:ID:       9f654cf1-b0da-4a5c-aeca-ad20bc22df82
:END:
#+title: #+title: Pentest - gRPC Port 50051
#+filetags: :grpc:pentest:


* gRPC
gRPC (short for Google Remote Procedure Call) is a modern open-source framework developed by Google for creating high-performance, language-agnostic remote procedure call (RPC) systems. It enables communication and interaction between different applications or services running on different platforms and written in different programming languages.

On Linux, gRPC provides a mechanism for building distributed systems by allowing services to communicate with each other efficiently and securely over a network. It utilizes the [[id:5741b471-8160-4846-8998-e5c11c8ae85b][HTTP/2]]  protocol as its transport layer and supports different serialization formats like Protocol Buffers (protobuf) for efficient data exchange.

To use gRPC on Linux, you typically follow these steps:

1. Define the interface: Start by defining the API using the Protocol Buffers language (protobuf). This involves creating a `.proto` file where you specify the service methods, message types, and their fields.

2. Generate code: Once you have the `.proto` file, you need to generate code in the target language you're using. There are gRPC code generators available for various programming languages. These generators will generate client and server stubs, allowing you to implement the service methods.

3. Implement the service: Write the server-side code that implements the service methods defined in the `.proto` file. This code will handle the actual logic and functionality of the service.

4. Build and run: Compile the generated code along with your implementation, and then run the server application. It will listen for incoming requests on a specified network port.

5. Create clients: Implement the client-side code to communicate with the server using the generated client stubs. Clients can make requests to the server, invoking the defined service methods.

6. Test and deploy: Test your gRPC service to ensure it functions correctly. Once satisfied, you can deploy it to production or use it as part of a larger distributed system.

gRPC simplifies the process of building scalable and efficient distributed systems by providing features like bi-directional streaming, flow control, authentication, and load balancing. It's widely used in various domains, including microservices architectures, cloud-native applications, and inter-service communication in large-scale systems.

Keep in mind that the specific implementation details may vary depending on the programming language you're using to build your gRPC service. However, the fundamental concepts and workflow remain consistent across platforms and languages.

** UI
akin to Postman : https://github.com/fullstorydev/grpcui
can act as middleware in order to test, eg, SQLi ([[id:61eb9f35-f735-4b5f-a028-0b2fd6ced177][SQL Injection]])
** Interceptor
https://dev.to/techschoolguru/use-grpc-interceptor-for-authorization-with-jwt-1c5h
** curl
https://github.com/fullstorydev/grpcurl#installation
** python
https://www.cloudbees.com/blog/using-grpc-in-python
