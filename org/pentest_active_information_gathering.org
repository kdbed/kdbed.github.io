:PROPERTIES:
:ID:       1d94dbf1-28d5-4f02-9104-788937768147
:END:
#+title: Pentest - Active Information Gathering
#+filetags: :p200:enumeration:pentest:
#+hugo_base_dir:../


* Active Information Gathering
** DNS
*** [[id:be9764f9-4ad6-412e-b660-e08491f08879][DNS - Basics]]
*** DNS Enumeration - Basics
DNS forward lookup brute-forcing to determine additional IPs belonging to a domain:
#+begin_src shell -n
for ip in $(cat list.txt); do host $ip.domain.com; done
#+end_src
Comprehensive lists available at [[https://github.com/danielmiessler/SecLists][SecLists]].
Based on IPs determined from the above, we can perform reverse lookups by scanning an associated range:
#+begin_src shell -n
for ip in $(seq 200 254); do host xxx.xxx.xxx.$ip; done | grep -v "not found"
#+end_src
*** [[https://github.com/darkoperator/dnsrecon][dnsrecon]]
*** [[https://github.com/SparrowOchon/dnsenum2][dnsenum2]]
*** nslookup

** TCP/UDP Port Scanning
Simple port scan with Netcat:
#+begin_src shell -n
nc -nvv -w 1 -z 192.168.1.2 3000-4000
#+end_src
where =-w= is timeout in seconds and =-z= specifies zero-I/O mode. TCP scans use the 3-way handshake to detect open ports.  UDP is stateless, so open port detection involves a different mechanism. Using Netcat:
#+begin_src shell -n
nc -nv -u -z -w 1 192.168.1.2 120-123
#+end_src
Here, if the destination UDP port is closed, the target should respond with an ICMP port unreachable. UDP scanning is often unreliable, as firewalls and routers may drop ICMP packets. This can lead to false positives and ports showing as open when they are, in fact, closed.
** [[id:f2fd2ce6-ba91-4772-9ce3-0ee7b045c222][Recon - Port Scanning and nmap]]



** Living off the Land
- Windows: [[https://lolbas-project.github.io/][lolbas]]
- Linux: [[https://gtfobins.github.io/][gtfobins]]
- Drivers: [[https://www.loldrivers.io/][loldrivers]]
