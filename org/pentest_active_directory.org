:PROPERTIES:
:ID:       e4956d71-b687-485c-9556-f9cb07ee2596
:END:
#+title: Pentest - Active Directory
#+filetags: :p200:activeDirectory:pentest:
#+hugo_base_dir:../


* Active Directory Enumeration
** Legacy Windows Tools
Use =net.exe= to gather user information
#+begin_src shell -n
net user /domain
#+end_src
A more detailed view of specific users in the output above:
#+begin_src shell -n
net user <username> /domain
#+end_src
Enumerate groups:
#+begin_src shell -n
net group /domain
#+end_src
Specifying a group:
#+begin_src shell -n
net group <groupname> /domain
#+end_src
** PowerShell and .NET
When RSAT tools aren't available, we can use an Active Directory Services Interface [[https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi][ADSI]] (a set of interfaces built on [[https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi(soft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsis://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal][COM]]) as an LDAP provider.  The LDAP ADsPath we need to consider to interact with the AD service is based on the following recipe:
#+begin_src shell -n
LDAP://HostName[:PortNumber][/DistinguishedName]
#+end_src
We could use the domain as the hostname, but this could potentially resolve to any of the DCs on the domain. To obtain the most accurate information, we'll look for the primary domain controller (PDC), which is the one holding the /PdcRoleOwner/ attribute.

Looking to .NET, we have the namespace /System.DirectoryServices.ActiveDirectory/, and specifically the /Domain Class/ therein. A method of interest is the following:
#+begin_src shell -n
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
#+end_src
which will provide the /PdcRoleOwner/ property, among others. We can use ADSI directly in PowerShell to retrieve the DN. We'll use two single quotes to indicate that the search starts at the top of the AD hierarchy.
#+begin_src shell -n
([adsi]'').distinguishedName
#+end_src
Putting it together, we can obtain the LDAP string:
#+begin_src shell -n
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName
$LDAP = "LDAP://$PDC/$DN"
$LDAP
#+end_src

In order to gather information, utilize two other classes in the /System.DirectoryServices/ namespace: /DirectoryEntry/ and /DirectorySearcher/. We'll pass the LDAP path to /DirectoryEntry/ in order to start the search at the top of the directory heirarchy. To perform queries with /DirectorySearcher/, we'll pass the /DirectoryEntry/ object as the /SearchRoot/.
#+begin_src shell -n
$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)
$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.filter="samAccountType=805306368"
$dirsearcher.FindAll()
#+end_src
where we've added the /samAccountType/ for users.  Iterate through the user properties and print:
#+begin_src shell -n
Foreach($obj in $result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }

    Write-Host "-------------------------------"
}
#+end_src
Wrap all of the above into a function:
#+begin_src shell -n
function LDAPSearch {
    param (
        [string]$LDAPQuery
    )

    $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
    $DistinguishedName = ([adsi]'').distinguishedName

    $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")

    $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)

    return $DirectorySearcher.FindAll()

}
#+end_src
We can import and run =LDAPSearch -LDAPQuery "(samAccountType=805306368)"=, or =LDAPSearch -LDAPQuery "(objectclass=group)"=

** Permissions and Sessions
*** PowerView: =Find-LocalAdminAccess=
Determine if the current user has admin access on any domain machines.  Relies on /OpenServiceW function/, which will connect to the /Service Control Manager (SCM)/ on the target machines.
*** PowerView: =Get-NetSession=
Determine which users are logged into which machines. It utilizes two Windows APIs: /NetWkstaUserEnum/ and /NetSessionEnum/. First requires admin privs, the second does not.
*** SysInternals: =PSLoggedon=
** Service Accounts
*** PowerView: =Get-NetUser -SPN | select samaccountname,serviceprincipalname=
Enumerate Service Principal Names (SPNs)
** Object Permissions
*** PowerView: =Get-ObjectAcl=
- Check the /ActiveDirectoryRights/ and /SecurityIdentifier/ attributes
- Dealing with SIDs: =Convert-SidToName=
** [[id:4dd9058d-b858-42c9-bc50-01ff7ce8474d][Bloodhound]]
* Active Directory Authentication
** [[id:ec636096-b811-4df4-bb2a-744d27dd1b01][NTLM Authentication]]
** [[id:8f260d6f-e943-4811-8f2a-0e75c89a0dcc][Kerberos Authentication]]
** Cached AD Credentials
*** [[id:7f39786c-3ddf-470e-9f1d-25d38304e294][Mimikatz]]
* Attacking Active Directory
** Password Attacks
- [[id:d7768ed2-25de-4a9b-92d1-4e419dcf6edc][PowerShell - Password Spray]]
- SMB - /crackmapexec/: =crackmapexec smb 192.168.1.2 -u users.txt -p 'Password123' -d domain.com --continue-on-success=
- [[id:d6ffa79f-f55e-4b01-97b8-29a6185f5bbc][Kerbrute]]
** [[id:22973ab0-77bb-4b77-8d4c-d52aa41e57a3][Pass the Ticket (PtT) Attack]]
Privileges: Domain user access
** [[id:78221ca4-7b41-4377-aa13-88d50a4fd30d][Kerberoasting]]
Privileges: Access as any user
** [[id:f6604f23-26b0-4da6-9c3d-f240b929526a][AS-REP Roasting]]
Privileges: Access as any user
** [[id:765f95f9-1043-4e3a-8145-4e7d49834e32][Golden Ticket]]
Privileges: Full domain compromise (domain admin)
** [[id:302b147c-f615-4e92-b84c-b81d182dab10][Silver Ticket]]
Privileges: Service hash
** [[id:07bedb89-943c-437f-859f-3a34cc6c2354][Skeleton Key]]
Privileges: Full domain compromise (domain admin)

* References
- [[https://dw3113r.com/2022/07/20/active-directory-attack-cheat-sheet/][dw3113r]]
