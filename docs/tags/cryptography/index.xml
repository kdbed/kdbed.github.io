<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cryptography on Owlglass</title>
    <link>https://kdbed.github.io/tags/cryptography/</link>
    <description>Recent content in Cryptography on Owlglass</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://kdbed.github.io/tags/cryptography/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cracking - PDF</title>
      <link>https://kdbed.github.io/posts/cracking_pdf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kdbed.github.io/posts/cracking_pdf/</guid>
      <description>fcrackzip fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt </description>
    </item>
    <item>
      <title>Hashing Vs Encryption</title>
      <link>https://kdbed.github.io/posts/hashing_vs_encryption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kdbed.github.io/posts/hashing_vs_encryption/</guid>
      <description>The difference between hashing and encryption The difference betwen hashing and encryption determines how likely an exposed password can be abused after a breach. Hashing is such that it can&amp;rsquo;t be directly reversed (hash &amp;ndash;&amp;gt; plaintext), but the plaintext can be guessed by hashing a large number of candidates and comparing the results. Password hashing is one-way and deterministic. This means that sites that store hashes never actually keep the password, but re-hashing at logon provides a reliable point of comparison.</description>
    </item>
    <item>
      <title>sha1Cracker</title>
      <link>https://kdbed.github.io/posts/sha1cracker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kdbed.github.io/posts/sha1cracker/</guid>
      <description>Implementing a sha1 hash cracker in Rust use sha1::Digest; use std::{ env, error::Error, fs::File, io::{BufRead, BufReader}, }; const SHA1_HEX_STRING_LENGTH: usize = 40; fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; { let args: Vec&amp;lt;String&amp;gt; = env::args().collect(); if args.len() != 3 { println!(&amp;#34;Usage:&amp;#34;); println!(&amp;#34;sha1_cracker: &amp;lt;wordlist.txt&amp;gt; &amp;lt;sha1_hash&amp;gt;&amp;#34;); return Ok(()); } let hash_to_crack = args[2].trim(); if hash_to_crack.len() != SHA1_HEX_STRING_LENGTH { return Err(&amp;#34;sha1 hash is not valid.&amp;#34;.into()); } let wordlist_file = File::open(&amp;amp;args[1])?; let reader = BufReader::new(&amp;amp;wordlist_file); for line in reader.</description>
    </item>
    <item>
      <title>Wildcard Certificate</title>
      <link>https://kdbed.github.io/posts/wildcard_certificate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kdbed.github.io/posts/wildcard_certificate/</guid>
      <description>Wildcare Certificates digicert&#xA;What is a SSL Wildcard Certificate?&#xA;A SSL/TLS Wildcard certificate is a single certificate with a wildcard character (*) in the domain name field. This allows the certificate to secure multiple sub domain names (hosts) pertaining to the same base domain.&#xA;For example, a wildcard certificate for *.(domainname).com, could be used for www.(domainname).com, mail.(domainname).com, store.(domainname).com, in addition to any additional sub domain name in the (domainname).com.&#xA;When a client checks the sub domain name in this type of certificate, it uses a shell expansion procedure to see if it matches.</description>
    </item>
  </channel>
</rss>
